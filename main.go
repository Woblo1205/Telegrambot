package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

var (
	msgstring string
)

type AutoGenerated struct {
	Success   bool   `json:"success"`
	Exception string `json:"exception"`
	Result    struct {
		InverterSN     string      `json:"inverterSN"`
		Sn             string      `json:"sn"`
		Acpower        float64     `json:"acpower"`
		Yieldtoday     float64     `json:"yieldtoday"`
		Yieldtotal     float64     `json:"yieldtotal"`
		Feedinpower    float64     `json:"feedinpower"`
		Feedinenergy   float64     `json:"feedinenergy"`
		Consumeenergy  float64     `json:"consumeenergy"`
		FeedinpowerM2  interface{} `json:"feedinpowerM2"`
		Soc            interface{} `json:"soc"`
		Peps1          interface{} `json:"peps1"`
		Peps2          interface{} `json:"peps2"`
		Peps3          interface{} `json:"peps3"`
		InverterType   string      `json:"inverterType"`
		InverterStatus string      `json:"inverterStatus"`
		UploadTime     string      `json:"uploadTime"`
		BatPower       interface{} `json:"batPower"`
		Powerdc1       float64     `json:"powerdc1"`
		Powerdc2       float64     `json:"powerdc2"`
		Powerdc3       interface{} `json:"powerdc3"`
		Powerdc4       interface{} `json:"powerdc4"`
		BatStatus      interface{} `json:"batStatus"`
	} `json:"result"`
}

func main() {

	StatusToString := make(map[string]string, 14)
	StatusToString["100"] = "Wait Mode"
	StatusToString["101"] = "Check Mode"
	StatusToString["102"] = "Normal Mode"
	StatusToString["103"] = "Fault Mode"
	StatusToString["104"] = "Permanent Faul Mode"
	StatusToString["105"] = "Update Mode"
	StatusToString["106"] = "EPS Check Mode"
	StatusToString["107"] = "EPS Mode"
	StatusToString["108"] = "Self-Test Mode"
	StatusToString["109"] = "Idle Mode"
	StatusToString["110"] = "Standby Mode"
	StatusToString["111"] = "Pv Wake Up Bat Mode"
	StatusToString["112"] = "Gen Check Mode"
	StatusToString["113"] = "Gen Run Mode"

	bot, err := tgbotapi.NewBotAPI("5606050346:AAHsH4LNgOCwvzi26QS2I_2MqZbkSG9zSM4")
	if err != nil {
		panic(err)
	}

	bot.Debug = true

	// Create a new UpdateConfig struct with an offset of 0. Offsets are used
	// to make sure Telegram knows we've handled previous values and we don't
	// need them repeated.
	updateConfig := tgbotapi.NewUpdate(0)

	// Tell Telegram we should wait up to 30 seconds on each request for an
	// update. This way we can get information just as quickly as making many
	// frequent requests without having to send nearly as many.
	updateConfig.Timeout = 30

	// Start polling Telegram for updates.
	updates := bot.GetUpdatesChan(updateConfig)

	// Let's go through each update that we're getting from Telegram.
	for update := range updates {
		// Telegram can send many types of updates depending on what your Bot
		// is up to. We only want to look at messages for now, so we can
		// discard any other updates.
		if update.Message == nil {
			continue
		}



		switch update.Message.Text {
		case "Status":
			if stringValue, ok := StatusToString[SolaxAPI().Result.InverterStatus]; ok {
				msgstring = stringValue
			} else {
				msgstring = "Error reading inverter status"
			}
		case "Power":
			msgstring = fmt.Sprintf("The current power output is: %v W", fmt.Sprintf("%v", SolaxAPI().Result.Acpower))
		case "Total":
			msgstring = fmt.Sprintf("The total power output is: %v kWh", fmt.Sprintf("%v", SolaxAPI().Result.Yieldtotal))
		case "Today":
			msgstring = fmt.Sprintf("The daily power output is: %v kWh", fmt.Sprintf("%v", SolaxAPI().Result.Yieldtoday))
		default:
			msgstring = "No command added to this input"
		}

		// Now that we know we've gotten a new message, we can construct a
		// reply! We'll take the Chat ID and Text from the incoming message
		// and use it to create a new message.
		msg := tgbotapi.NewMessage(update.Message.Chat.ID, msgstring)

		// We'll also say that this message is a reply to the previous message.
		// For any other specifications than Chat ID or Text, you'll need to
		// set fields on the `MessageConfig`.
		msg.ReplyToMessageID = update.Message.MessageID

		// Okay, we're sending our message off! We don't care about the message
		// we just sent, so we'll discard it.
		if _, err := bot.Send(msg); err != nil {
			// Note that panics are a bad way to handle errors. Telegram can
			// have service outages or network errors, you should retry sending
			// messages or more gracefully handle failures.
			panic(err)
		}
	}

}

func SolaxAPI() AutoGenerated {

	url := "https://www.solaxcloud.com:9443/proxy/api/getRealtimeInfo.do?tokenId=202211122144295660197013&sn=SX7Z9PU3QR"

	req, err := http.NewRequest("GET", url, nil)

	if err != nil {
		log.Fatalf("Error setting up API request: %v", err)
	}

	req.Header.Add("Authorization", "Basic eDAzMDg0NTpJbml0UHdkITEyMDU5ODg5MQ==")

	res, err := http.DefaultClient.Do(req)

	if err != nil {
		log.Fatalf("Error making API request: %v", err)
	}

	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)

	if err != nil {
		log.Fatalf("Error reading API request: %v", err)
	}

	var data AutoGenerated

	err = json.Unmarshal(body, &data)

	if err != nil {
		fmt.Printf("Error marshalling JSON data: %v", err)
	}

	return data
}
